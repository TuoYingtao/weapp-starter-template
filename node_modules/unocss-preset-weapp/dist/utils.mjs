import { t as getBracket } from './shared/unocss-preset-weapp.081deb7c.mjs';
export { C as CONTROL_MINI_NO_NEGATIVE, j as colorOpacityToString, c as colorResolver, f as colorToString, b as colorableShadows, l as cornerMap, w as cssMathFnRE, k as directionMap, q as directionSize, A as getComponent, B as getComponents, g as globalKeywords, d as h, h as handler, a as hasParseableColor, u as hex2rgba, o as insetMap, i as isCSSMathFn, n as isSize, m as makeGlobalStaticRules, e as parseColor, v as parseCssColor, p as positionMap, r as resolveBreakpoints, z as resolveVerticalBreakpoints, s as splitShorthand, y as valueHandlers, x as xyzMap } from './shared/unocss-preset-weapp.081deb7c.mjs';
import { escapeRegExp } from '@unocss/core';
import { cacheRestoreSelector, defaultRules } from 'unplugin-transform-class/utils';
import '@unocss/rule-utils';

function variantMatcher(name, handler, transformRules = defaultRules) {
  let re;
  return {
    name,
    match(input, ctx) {
      if (!re)
        re = new RegExp(`^${escapeRegExp(name)}(?:${ctx.generator.config.separators.join("|")})`);
      input = cacheRestoreSelector(input, transformRules);
      const match = input.match(re);
      if (match) {
        return {
          matcher: input.slice(match[0].length),
          handle: (input2, next) => next({
            ...input2,
            ...handler(input2)
          })
        };
      }
    },
    autocomplete: `${name}:`
  };
}
function variantParentMatcher(name, parent, transformRules = defaultRules) {
  let re;
  return {
    name,
    match(input, ctx) {
      if (!re)
        re = new RegExp(`^${escapeRegExp(name)}(?:${ctx.generator.config.separators.join("|")})`);
      input = cacheRestoreSelector(input, transformRules);
      const match = input.match(re);
      if (match) {
        return {
          matcher: input.slice(match[0].length),
          handle: (input2, next) => next({
            ...input2,
            parent: `${input2.parent ? `${input2.parent} $$ ` : ""}${parent}`
          })
        };
      }
    },
    autocomplete: `${name}:`
  };
}
function variantGetBracket(prefix, matcher, separators) {
  if (matcher.startsWith(`${prefix}[`)) {
    const [match, rest] = getBracket(matcher.slice(prefix.length), "[", "]") ?? [];
    if (match && rest) {
      for (const separator of separators) {
        if (rest.startsWith(separator))
          return [match, rest.slice(separator.length), separator];
      }
      return [match, rest, ""];
    }
  }
}
function variantGetParameter(prefix, matcher, separators) {
  if (matcher.startsWith(prefix)) {
    const body = variantGetBracket(prefix, matcher, separators);
    if (body) {
      const [label = "", rest = body[1]] = variantGetParameter("/", body[1], separators) ?? [];
      return [body[0], rest, label];
    }
    for (const separator of separators.filter((x) => x !== "/")) {
      const pos = matcher.indexOf(separator, prefix.length);
      if (pos !== -1) {
        const labelPos = matcher.indexOf("/", prefix.length);
        const unlabelled = labelPos === -1 || pos <= labelPos;
        return [
          matcher.slice(prefix.length, unlabelled ? pos : labelPos),
          matcher.slice(pos + separator.length),
          unlabelled ? "" : matcher.slice(labelPos + 1, pos)
        ];
      }
    }
  }
}

export { getBracket, variantGetBracket, variantGetParameter, variantMatcher, variantParentMatcher };
