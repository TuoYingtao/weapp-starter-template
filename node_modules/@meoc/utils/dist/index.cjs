'use strict';

const dayjs = require('dayjs');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const dayjs__default = /*#__PURE__*/_interopDefaultCompat(dayjs);

function removeAt(arr, el) {
  const i = arr.indexOf(el);
  if (i > -1)
    arr.splice(i, 1);
}
function insertAt(arr, index, ...v) {
  arr.splice(index + 1, 0, ...v);
  return arr;
}
function last(arr) {
  return arr && (arr.length ? arr[arr.length - 1] : void 0);
}
const lastN = (arr, n) => arr.slice(-n);
function all(arr, fn) {
  return arr.every(fn);
}
function allEqual(arr) {
  return arr.every((val) => val === arr[0]);
}
function createArray(length, value) {
  return Array.from({ length }).fill(value);
}
function shuffleArray(arr) {
  return arr.sort(() => Math.random() - 0.5);
}
function removeDuplicates(arr) {
  return [...new Set(arr)];
}
function removeByProp(arr, prop) {
  return [
    ...arr.reduce((prev, cur) => prev.set(cur[prop], cur), /* @__PURE__ */ new Map()).values()
  ];
}
function intersection(...arr) {
  return [...new Set(arr[0])].filter((v) => arr.every((b) => b.includes(v)));
}
function indexOfMax(arr) {
  return arr.reduce((prev, curr, i, a) => curr > a[prev] ? i : prev, 0);
}
function indexOfMin(arr) {
  return arr.reduce((prev, curr, i, a) => curr < a[prev] ? i : prev, 0);
}
function closest(arr, n) {
  return arr.reduce((prev, curr) => Math.abs(curr - n) < Math.abs(prev - n) ? curr : prev);
}
function transpose(matrix) {
  return matrix[0].map((_, i) => matrix.map((row) => row[i]));
}
function groupArrayByKey(arr = [], key) {
  return arr.reduce((t, v) => {
    !t[v[key]] ? t[v[key]] = [v] : t[v[key]].push(v);
    return t;
  }, {});
}

function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function normalize(obj) {
  if (typeof obj === "object") {
    const result = clone(obj);
    for (const key in result) {
      const current = result[key];
      if ([null, ""].includes(current) || isArray(current) && current.length === 0)
        delete result[key];
      else
        result[key] = normalize(current);
    }
    return result;
  }
  if (isArray(obj))
    return obj.map((item) => normalize(item));
  return obj;
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(val, key) {
  return hasOwnProperty.call(val, key);
}
const objectToString = Object.prototype.toString;
function toTypeString(value) {
  return objectToString.call(value);
}
function hasChanged(value, oldValue) {
  return !Object.is(value, oldValue);
}
function getByPath(obj, path, defaultValue = "no value") {
  const parts = path.split(".");
  const key = parts.shift();
  if (!isUndefined(key) && !isUndefined(obj[key])) {
    return parts.length > 0 ? getByPath(obj[key], parts.join("."), defaultValue) : obj[key];
  }
  return defaultValue;
}
function omit(obj, paths) {
  return Object.keys(obj).reduce((acc, key) => {
    if (!paths.includes(key))
      hasOwn(obj, key) && (acc[key] = obj[key]);
    return acc;
  }, {});
}
function omitBy(obj, predicate) {
  const result = {};
  for (const key in obj) {
    const curProperty = obj[key];
    if (!predicate(curProperty, key))
      result[key] = curProperty;
  }
  return result;
}
function pick(obj, paths = []) {
  return paths.reduce((acc, key) => {
    hasOwn(obj, key) && (acc[key] = obj[key]);
    return acc;
  }, {});
}
function pickBy(obj, predicate) {
  const result = {};
  for (const key in obj) {
    const curProperty = obj[key];
    if (predicate(curProperty, key))
      result[key] = curProperty;
  }
  return result;
}

function sleep(ms, callback) {
  return new Promise(
    (resolve) => setTimeout(async () => {
      callback && await callback();
      resolve();
    }, ms)
  );
}
function loadJs(urls, done) {
  const head = document.getElementsByTagName("head")[0];
  Promise.all(urls.map((url) => {
    return new Promise((resolve) => {
      const s = document.createElement("script");
      s.type = "text/javascript";
      s.async = true;
      s.src = url;
      s.addEventListener("load", (e) => resolve(e), false);
      head.appendChild(s);
    });
  })).then(done);
}

const camelizeRE = /-(\w)/g;
function camelize(str) {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
}
function toPascalCase(str) {
  return str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).map((x) => x.charAt(0).toUpperCase() + x.slice(1).toLowerCase()).join("");
}
function toCamelCase(str) {
  const s = str && str.match(
    /[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g
  ).map((x) => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase()).join("");
  return s.slice(0, 1).toLowerCase() + s.slice(1);
}
function toKebabCase(str) {
  return str && str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).map((x) => x.toLowerCase()).join("-");
}
function toSnakeCase(str) {
  return str && str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).map((x) => x.toLowerCase()).join("_");
}
const toCharArray = (s) => [...s];
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const hyphenateRE = /\B([A-Z])/g;
function hyphenate(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
}
function replaceAll(text, repstr, newstr) {
  return text.replace(new RegExp(repstr, "gm"), newstr);
}
function trim(value) {
  return value.replace(/(^\s*)|(\s*$)/g, "");
}
function trimAll(value) {
  return value.replace(/\s+/g, "");
}
function getHanByNumber(num) {
  const HAN_STR = "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D\u5341";
  return HAN_STR.charAt(num);
}
function getDayByNumber(num) {
  const DAY_STR = "\u65E5\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u65E5";
  return `\u5468${DAY_STR.charAt(num)}`;
}
function insertStr(str, start, insertStr2) {
  return str.slice(0, start) + insertStr2 + str.slice(start);
}
function escapeHTML(str) {
  return str.replace(
    /[&<>'"]/g,
    (tag) => ({
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "'": "&#39;",
      '"': "&quot;"
    })[tag] || tag
  );
}
const removeWhitespace = (str) => str.replace(/\s+/g, "");

function compareVersion(v1, v2) {
  const v1Arr = v1.split(".");
  const v2Arr = v2.split(".");
  const len = Math.max(v1Arr.length, v2Arr.length);
  while (v1Arr.length < len)
    v1Arr.push("0");
  while (v2Arr.length < len)
    v2Arr.push("0");
  for (let i = 0; i < len; i++) {
    const num1 = +v1Arr[i];
    const num2 = +v2Arr[i];
    if (num1 > num2)
      return 1;
    else if (num1 < num2)
      return -1;
  }
  return 0;
}

const HTTP_STATUS = {
  /**
   * HTTP Status-Code 200: OK(正常).
   */
  OK: 200,
  /**
   * HTTP Status-Code 201: Created(201：已创建).
   */
  CREATED: 201,
  /**
   * HTTP Status-Code 202: Accepted(已接受).
   */
  ACCEPTED: 202,
  /**
   * HTTP Status-Code 203: Non-Authoritative Information(非权威信息).
   */
  NOT_AUTHORITATIVE: 203,
  /**
   * HTTP Status-Code 204: No Content(无内容).
   */
  NO_CONTENT: 204,
  /**
   * HTTP Status-Code 205: Reset Content(重置内容).
   */
  RESET: 205,
  /**
   * HTTP Status-Code 206: Partial Content(部分内容).
   */
  PARTIAL: 206,
  /* 3XX: relocation/redirect(搬迁/重定向) */
  /**
  * HTTP Status-Code 300: Multiple Choices(多项选择).
  */
  MULT_CHOICE: 300,
  /**
  * HTTP Status-Code 301: Moved Permanently(永久移动).
  */
  MOVED_PERM: 301,
  /**
  * HTTP Status-Code 302: Temporary Redirect(临时重定向).
  */
  MOVED_TEMP: 302,
  /**
  * HTTP Status-Code 303: See Other(请参阅其他).
  */
  SEE_OTHER: 303,
  /**
  * HTTP Status-Code 304: Not Modified(未修改).
  */
  NOT_MODIFIED: 304,
  /**
  * HTTP Status-Code 305: Use Proxy(使用代理).
  */
  USE_PROXY: 305,
  /* 4XX: client error (客户端错误) */
  /**
  * HTTP Status-Code 400: Bad Request(错误请求).
  */
  BAD_REQUEST: 400,
  /**
  * HTTP Status-Code 401: Unauthorized(未经授权).
  */
  UNAUTHORIZED: 401,
  /**
  * HTTP Status-Code 402: Payment Required(需要付款).
  */
  PAYMENT_REQUIRED: 402,
  /**
  * HTTP Status-Code 403: Forbidden(禁止访问).
  */
  FORBIDDEN: 403,
  /**
  * HTTP Status-Code 404: Not Found(未找到).
  */
  NOT_FOUND: 404,
  /**
  * HTTP Status-Code 405: Method Not Allowed(方法不允许).
  */
  BAD_METHOD: 405,
  /**
  * HTTP Status-Code 406: Not Acceptable(不可接受).
  */
  NOT_ACCEPTABLE: 406,
  /**
  * HTTP Status-Code 407: Proxy Authentication Required(需要代理身份验证).
  */
  PROXY_AUTH: 407,
  /**
  * HTTP Status-Code 408: Request Time-Out(请求超时).
  */
  CLIENT_TIMEOUT: 408,
  /**
  * HTTP Status-Code 409: Conflict(冲突).
  */
  CONFLICT: 409,
  /**
  * HTTP Status-Code 410: Gone(消失).
  */
  GONE: 410,
  /**
  * HTTP Status-Code 411: Length Required(需要长度).
  */
  LENGTH_REQUIRED: 411,
  /**
  * HTTP Status-Code 412: Precondition Failed(前提条件失败).
  */
  PRECON_FAILED: 412,
  /**
  * HTTP Status-Code 413: Request Entity Too Large(请求实体太大).
  */
  ENTITY_TOO_LARGE: 413,
  /**
  * HTTP Status-Code 414: Request-URI Too Large(请求 URI 太大).
  */
  REQ_TOO_LONG: 414,
  /**
  * HTTP Status-Code 415: Unsupported Media Type(不支持的媒体类型).
  */
  UNSUPPORTED_TYPE: 415,
  /* 5XX: server error */
  /**
  * HTTP Status-Code 500: Internal Server Error(内部服务器错误).
  */
  INTERNAL_ERROR: 500,
  /**
  * HTTP Status-Code 501: Not Implemented(未实现).
  */
  NOT_IMPLEMENTED: 501,
  /**
  * HTTP Status-Code 502: Bad Gateway(网关错误).
  */
  BAD_GATEWAY: 502,
  /**
  * HTTP Status-Code 503: Service Unavailable(服务不可用).
  */
  UNAVAILABLE: 503,
  /**
  * HTTP Status-Code 504: Gateway Timeout(网关超时).
  */
  GATEWAY_TIMEOUT: 504,
  /**
  * HTTP Status-Code 505: HTTP Version Not Supported(不支持 HTTP 版本).
  */
  VERSION: 505
};
var DATE_FORMAT = /* @__PURE__ */ ((DATE_FORMAT2) => {
  DATE_FORMAT2["TO_MINUTE"] = "YYYY-MM-DD HH:mm";
  DATE_FORMAT2["TO_HOUR"] = "YYYY-MM-DD HH";
  DATE_FORMAT2["TO_DAY"] = "YYYY-MM-DD";
  DATE_FORMAT2["TO_MONT"] = "YYYY-MM";
  DATE_FORMAT2["TO_YEAR"] = "YYYY";
  DATE_FORMAT2["TO_SECOND"] = "YYYY-MM-DD HH:mm:ss";
  return DATE_FORMAT2;
})(DATE_FORMAT || {});
const HTTP_CONTENT_TYPE = {
  JSON: "application/json",
  FORM_URLENCODED: "application/x-www-form-urlencoded",
  FORM_DATA: "multipart/form-data",
  TEXT: "text/plain;charset:UTF-8",
  ZIP: "application/zip"
};
const HTTP_REQUEST = {
  GET: "GET",
  POST: "POST",
  PUT: "PUT",
  DELETE: "DELETE"
};
const TYPE_OF = {
  NUMBER: "number",
  STRING: "string",
  FUNCTION: "function",
  SYMBOL: "symbol",
  OBJECT_STR: "object",
  BOOLEAN: "[object Boolean]",
  NULL: "[object Null]",
  UNDEFINED: "[object Undefined]",
  OBJECT: "[object Object]",
  ARRAY: "[object Array]",
  DATE: "[object Date]",
  REGEXP: "[object RegExp]",
  SET: "[object Set]",
  MAP: "[object Map]",
  FILE: "[object File]"
};

function formatDate(date, format = DATE_FORMAT.TO_SECOND) {
  if (!date)
    date = /* @__PURE__ */ new Date();
  return dayjs__default(date).format(format);
}
function getNow(format = DATE_FORMAT.TO_DAY) {
  return dayjs__default().format(format);
}
function getFirstDayOfMonth(date, format = DATE_FORMAT.TO_DAY) {
  if (!date)
    date = /* @__PURE__ */ new Date();
  return dayjs__default(date).startOf("month").format(format);
}
function getLastDayOfMonth(date, format = DATE_FORMAT.TO_DAY) {
  if (!date)
    date = /* @__PURE__ */ new Date();
  return dayjs__default(date).endOf("month").format(format);
}
function getDaysOfMonth(date, format = DATE_FORMAT.TO_DAY) {
  return [getFirstDayOfMonth(date, format), getLastDayOfMonth(date, format)];
}
function getDaysOfLastMonth(format = DATE_FORMAT.TO_DAY) {
  const month = dayjs__default().subtract(1, "month").toDate();
  return [getFirstDayOfMonth(month, format), getLastDayOfMonth(month, format)];
}
function getDaysToNowOfMonth(date, format = DATE_FORMAT.TO_DAY) {
  return [getFirstDayOfMonth(date, format), getNow(format)];
}
function getFirstDayOfYear(date, format = DATE_FORMAT.TO_DAY) {
  if (!date)
    date = /* @__PURE__ */ new Date();
  return dayjs__default(date).startOf("year").format(format);
}
function getDaysOfWeek(format = DATE_FORMAT.TO_DAY) {
  return [
    dayjs__default().startOf("week").format(format),
    dayjs__default().endOf("week").format(format)
  ];
}
function isAfter(d1, d2 = /* @__PURE__ */ new Date()) {
  return dayjs__default(d2).isAfter(d1);
}
function isBefore(d1, d2 = /* @__PURE__ */ new Date()) {
  return dayjs__default(d2).isBefore(d1);
}
function isBetween(d1, d2, d3 = /* @__PURE__ */ new Date()) {
  return isAfter(d1, d3) && isBefore(d2, d3);
}
function addDays(days = 1, d = /* @__PURE__ */ new Date(), format = DATE_FORMAT.TO_DAY) {
  return dayjs__default(d).add(days, "day").format(format);
}
function subDays(days = 1, d = /* @__PURE__ */ new Date(), format = DATE_FORMAT.TO_DAY) {
  return dayjs__default(d).subtract(days, "day").format(format);
}
function toDate(date) {
  if (typeof date === "string")
    return dayjs__default(date).toDate();
  return date.map((item) => dayjs__default(item).toDate());
}

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function toNumber(val) {
  const n = isString(val) ? Number(val) : Number.NaN;
  return Number.isNaN(n) ? val : n;
}

function isArray(obj) {
  return Array.isArray(obj);
}
const isMap = (val) => toTypeString(val) === TYPE_OF.MAP;
const isSet = (val) => toTypeString(val) === TYPE_OF.SET;
const isString = (val) => typeof val === TYPE_OF.STRING;
const isDate = (val) => toTypeString(val) === TYPE_OF.DATE;
const isFunction = (val) => typeof val === TYPE_OF.FUNCTION;
const isSymbol = (val) => typeof val === TYPE_OF.SYMBOL;
const isObject = (val) => val !== null && typeof val === TYPE_OF.OBJECT_STR;
function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
}
const isNumber = (val) => typeof val === TYPE_OF.NUMBER;
const isNull = (val) => toTypeString(val) === TYPE_OF.NULL;
const isUndefined = (val) => toTypeString(val) === TYPE_OF.UNDEFINED;
const isRegExp = (val) => toTypeString(val) === TYPE_OF.REGEXP;
const isFile = (val) => toTypeString(val) === TYPE_OF.FILE;
const isPlainObject = (val) => toTypeString(val) === TYPE_OF.OBJECT;
function isUndef(v) {
  return isNull(v) || isUndefined(v);
}
function isEmptyString(v) {
  return isString(v) && v.trim().length === 0;
}
function isEmpty(val) {
  return val == null || !(Object.keys(val) || val).length;
}

function invokeArrayFns(fns, args) {
  let _args = args;
  if (isObject(_args))
    _args = clone(args);
  for (const fn of fns) {
    const data = fn(_args);
    _args = data;
  }
  return _args;
}
async function invokeArrayAsyncFns(fns, args) {
  let _args = clone(args);
  for (const fn of fns) {
    const data = await fn(_args);
    _args = data;
  }
  return _args;
}
function stringHash(str) {
  let hash = 5381;
  let i = str.length;
  while (i--)
    hash = (hash << 5) - hash ^ str.charCodeAt(i);
  return hash >>> 0;
}
function uuid() {
  return Array.from(
    { length: 16 },
    () => Math.floor(Math.random() * 256).toString(16).padStart(2, "0")
  ).join("");
}
const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid(defaultSize = 21, alphabet = urlAlphabet) {
  let id = "";
  let i = defaultSize;
  while (i--) {
    id += alphabet[Math.random() * 64 | 0];
  }
  return id;
}
function hideMobile(mobile) {
  return mobile.replace(/^(\d{3})\d{4}(\d{4})$/, "$1****$2");
}
function params2Url(obj, encode = false) {
  const params = [];
  for (const key in obj)
    params.push(`${key}=${obj[key]}`);
  const paramsStr = params.join("&");
  return encode ? encodeURIComponent(paramsStr) : paramsStr;
}
function seconds2Time(seconds) {
  const hour = Math.floor(seconds / 3600);
  const minute = Math.floor((seconds - hour * 3600) / 60);
  const second = seconds - hour * 3600 - minute * 60;
  return `${fillZero(hour)}:${fillZero(minute)}:${fillZero(second)}`;
}
function seconds2DayTime(seconds) {
  const day = Math.floor(seconds / 86400);
  const hour = Math.floor((seconds - day * 86400) / 3600);
  const minute = Math.floor((seconds - day * 86400 - hour * 3600) / 60);
  const second = seconds - day * 86400 - hour * 3600 - minute * 60;
  return `${fillZero(day)}:${fillZero(hour)}:${fillZero(minute)}:${fillZero(second)}`;
}
function fillZero(num) {
  return num.toString().padStart(2, "0");
}
function toCurryFunc(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return (...args2) => {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}
function debounce(fn, wait = 800) {
  let timer;
  return function(...args) {
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, wait);
  };
}
function throttle(fn, wait = 800) {
  let timer;
  return function(...args) {
    if (timer)
      return;
    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = void 0;
    }, wait);
  };
}
var OSType = /* @__PURE__ */ ((OSType2) => {
  OSType2[OSType2["IOS"] = 1] = "IOS";
  OSType2[OSType2["Android"] = 2] = "Android";
  OSType2[OSType2["Other"] = 3] = "Other";
  return OSType2;
})(OSType || {});
function getOSType() {
  const u = navigator.userAgent;
  const isAndroid = u.includes("Android") || u.includes("Linux");
  const isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
  if (isIOS)
    return 1 /* IOS */;
  if (isAndroid)
    return 2 /* Android */;
  return 3 /* Other */;
}

function drawImageVerify({ dom, width = 152, height = 40, code = "" }) {
  const NUMBER_STRING = "0123456789";
  const ctx = dom.getContext("2d");
  if (!ctx)
    return code;
  ctx.fillStyle = randomRgbColor(180, 230);
  ctx.fillRect(0, 0, width, height);
  for (let i = 0; i < 4; i += 1) {
    let text = "";
    if (code) {
      text = code.charAt(i);
    } else {
      text = NUMBER_STRING[randomIntegerInRange(0, NUMBER_STRING.length - 1)];
      code += text;
    }
    const fontSize = randomIntegerInRange(18, 41);
    const deg = randomIntegerInRange(-30, 30);
    ctx.font = `${fontSize}px Simhei`;
    ctx.textBaseline = "top";
    ctx.fillStyle = randomRgbColor(80, 150);
    ctx.save();
    ctx.translate(30 * i + 23, 15);
    ctx.rotate(deg * Math.PI / 180);
    ctx.fillText(text, -15 + 5, -15);
    ctx.restore();
  }
  for (let i = 0; i < 5; i += 1) {
    ctx.beginPath();
    ctx.moveTo(randomIntegerInRange(0, width), randomIntegerInRange(0, height));
    ctx.lineTo(randomIntegerInRange(0, width), randomIntegerInRange(0, height));
    ctx.strokeStyle = randomRgbColor(180, 230);
    ctx.closePath();
    ctx.stroke();
  }
  for (let i = 0; i < 41; i += 1) {
    ctx.beginPath();
    ctx.arc(randomIntegerInRange(0, width), randomIntegerInRange(0, height), 1, 0, 2 * Math.PI);
    ctx.closePath();
    ctx.fillStyle = randomRgbColor(150, 200);
    ctx.fill();
  }
  return code;
}

function rgbToHex(r, g, b) {
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
function toHex(n) {
  if (isString(n))
    n = Number.parseInt(n, 10);
  if (Number.isNaN(n))
    return "00";
  n = Math.max(0, Math.min(n, 255));
  return "0123456789ABCDEF".charAt((n - n % 16) / 16) + "0123456789ABCDEF".charAt(n % 16);
}
function hexToRGB(hex) {
  if (hex.length === 4) {
    const text = hex.substring(1, 4);
    hex = `#${text}${text}`;
  }
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: Number.parseInt(result[1], 16),
    g: Number.parseInt(result[2], 16),
    b: Number.parseInt(result[3], 16)
  } : null;
}

function randomHexColorCode() {
  const n = (Math.random() * 1048575 * 1e6).toString(16);
  return `#${n.slice(0, 6)}`;
}
function randomRgbColor(min = 0, max = 255) {
  const r = randomIntegerInRange(min, max);
  const g = randomIntegerInRange(min, max);
  const b = randomIntegerInRange(min, max);
  return `rgb(${r},${g},${b})`;
}
function randomBoolean() {
  return Math.random() >= 0.5;
}
function randomIntegerInRange(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function randomNumberInRange(min, max) {
  return Math.random() * (max - min) + min;
}

function required() {
  throw new Error("\u65B9\u6CD5\u7F3A\u5C11\u5FC5\u8981\u53C2\u6570");
}

function download(link, name) {
  if (!name)
    name = link.slice(link.lastIndexOf("/") + 1);
  const eleLink = document.createElement("a");
  eleLink.download = name;
  eleLink.style.display = "none";
  eleLink.href = link;
  document.body.appendChild(eleLink);
  eleLink.click();
  document.body.removeChild(eleLink);
}
function downloadFile(name, content) {
  if (typeof name == "undefined")
    throw new Error("The first parameter name is a must");
  if (typeof content == "undefined")
    throw new Error("The second parameter content is a must");
  if (!(content instanceof Blob))
    content = new Blob([content]);
  const link = URL.createObjectURL(content);
  download(link, name);
}
function isMobileAgent(agent) {
  return /Android|webOS|iPhone|iPod|BlackBerry|Mobile/i.test(agent);
}
function isMobile() {
  return isMobileAgent(navigator.userAgent);
}
function reload() {
  location.reload();
}
function goToTop() {
  window.scrollTo(0, 0);
}
function goTo(url) {
  location.href = url;
}
function scrollToTop(element) {
  element.scrollIntoView({ behavior: "smooth", block: "start" });
}
function scrollToBottom(element) {
  element.scrollIntoView({ behavior: "smooth", block: "end" });
}

exports.DATE_FORMAT = DATE_FORMAT;
exports.HTTP_CONTENT_TYPE = HTTP_CONTENT_TYPE;
exports.HTTP_REQUEST = HTTP_REQUEST;
exports.HTTP_STATUS = HTTP_STATUS;
exports.OSType = OSType;
exports.TYPE_OF = TYPE_OF;
exports.addDays = addDays;
exports.all = all;
exports.allEqual = allEqual;
exports.camelize = camelize;
exports.capitalize = capitalize;
exports.clone = clone;
exports.closest = closest;
exports.compareVersion = compareVersion;
exports.createArray = createArray;
exports.debounce = debounce;
exports.download = download;
exports.downloadFile = downloadFile;
exports.drawImageVerify = drawImageVerify;
exports.escapeHTML = escapeHTML;
exports.escapeRegExp = escapeRegExp;
exports.formatDate = formatDate;
exports.getByPath = getByPath;
exports.getDayByNumber = getDayByNumber;
exports.getDaysOfLastMonth = getDaysOfLastMonth;
exports.getDaysOfMonth = getDaysOfMonth;
exports.getDaysOfWeek = getDaysOfWeek;
exports.getDaysToNowOfMonth = getDaysToNowOfMonth;
exports.getFirstDayOfMonth = getFirstDayOfMonth;
exports.getFirstDayOfYear = getFirstDayOfYear;
exports.getHanByNumber = getHanByNumber;
exports.getLastDayOfMonth = getLastDayOfMonth;
exports.getNow = getNow;
exports.getOSType = getOSType;
exports.goTo = goTo;
exports.goToTop = goToTop;
exports.groupArrayByKey = groupArrayByKey;
exports.hasChanged = hasChanged;
exports.hasOwn = hasOwn;
exports.hexToRGB = hexToRGB;
exports.hideMobile = hideMobile;
exports.hyphenate = hyphenate;
exports.indexOfMax = indexOfMax;
exports.indexOfMin = indexOfMin;
exports.insertAt = insertAt;
exports.insertStr = insertStr;
exports.intersection = intersection;
exports.invokeArrayAsyncFns = invokeArrayAsyncFns;
exports.invokeArrayFns = invokeArrayFns;
exports.isAfter = isAfter;
exports.isArray = isArray;
exports.isBefore = isBefore;
exports.isBetween = isBetween;
exports.isDate = isDate;
exports.isEmpty = isEmpty;
exports.isEmptyString = isEmptyString;
exports.isFile = isFile;
exports.isFunction = isFunction;
exports.isMap = isMap;
exports.isMobile = isMobile;
exports.isMobileAgent = isMobileAgent;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isPromise = isPromise;
exports.isRegExp = isRegExp;
exports.isSet = isSet;
exports.isString = isString;
exports.isSymbol = isSymbol;
exports.isUndef = isUndef;
exports.isUndefined = isUndefined;
exports.last = last;
exports.lastN = lastN;
exports.loadJs = loadJs;
exports.nanoid = nanoid;
exports.normalize = normalize;
exports.objectToString = objectToString;
exports.omit = omit;
exports.omitBy = omitBy;
exports.params2Url = params2Url;
exports.pick = pick;
exports.pickBy = pickBy;
exports.randomBoolean = randomBoolean;
exports.randomHexColorCode = randomHexColorCode;
exports.randomIntegerInRange = randomIntegerInRange;
exports.randomNumberInRange = randomNumberInRange;
exports.randomRgbColor = randomRgbColor;
exports.reload = reload;
exports.removeAt = removeAt;
exports.removeByProp = removeByProp;
exports.removeDuplicates = removeDuplicates;
exports.removeWhitespace = removeWhitespace;
exports.replaceAll = replaceAll;
exports.required = required;
exports.rgbToHex = rgbToHex;
exports.scrollToBottom = scrollToBottom;
exports.scrollToTop = scrollToTop;
exports.seconds2DayTime = seconds2DayTime;
exports.seconds2Time = seconds2Time;
exports.shuffleArray = shuffleArray;
exports.sleep = sleep;
exports.stringHash = stringHash;
exports.subDays = subDays;
exports.throttle = throttle;
exports.toCamelCase = toCamelCase;
exports.toCharArray = toCharArray;
exports.toCurryFunc = toCurryFunc;
exports.toDate = toDate;
exports.toHex = toHex;
exports.toKebabCase = toKebabCase;
exports.toNumber = toNumber;
exports.toPascalCase = toPascalCase;
exports.toSnakeCase = toSnakeCase;
exports.toTypeString = toTypeString;
exports.transpose = transpose;
exports.trim = trim;
exports.trimAll = trimAll;
exports.uuid = uuid;
